# EDAMAME Endpoint Threat Models

## Table of Contents
- [Overview](#overview)
- [Database Generation and Management](#database-generation-and-management)
  - [Port Vulnerability Database](#port-vulnerability-database)
  - [Vendor Vulnerability Database](#vendor-vulnerability-database)
  - [Device Profile Database](#device-profile-database)
  - [Whitelist Database](#whitelist-database)
  - [Database Integrity and Updates](#database-integrity-and-updates)
- [Threat Dimensions](#threat-dimensions)
- [Naming Conventions](#naming-conventions)
- [Model Structure](#model-structure)
  - [JSON Format](#json-format)
  - [Key Fields](#key-fields)
- [Implementation Types](#implementation-types)
  - [System Checks](#system-checks)
  - [Command Line Checks](#command-line-checks)
  - [Business Rules](#business-rules)
- [Platform Coverage](#platform-coverage)
- [Security Assessment](#security-assessment)
  - [Severity Classification](#severity-classification)
  - [Compliance Frameworks](#compliance-frameworks)
- [Privacy Protection](#privacy-protection)
  - [Important Note on Business Rules](#important-note-on-business-rules)
- [Additional Features](#additional-features)
  - [Internationalization](#internationalization)
  - [Implementation Details](#implementation-details)
  - [Remediation Guidance](#remediation-guidance)
- [EDAMAME Ecosystem](#edamame-ecosystem)

## Overview

This repository contains the threat models used by the EDAMAME Security application to compute its Security Score. These models are based on industry-standard benchmarks including NIST and CIS, as well as other authoritative sources.

The EDAMAME Security platform leverages these models to provide comprehensive security posture assessment while ensuring user privacy and preventing administrative overreach.

## Database Generation and Management

EDAMAME Security relies on several specialized databases that power its detection capabilities. These databases are maintained through a combination of automated scripts and manual curation to ensure accuracy and relevance.

### Port Vulnerability Database

The `lanscan-port-vulns-db.json` database catalogs vulnerabilities associated with TCP ports. This database is automatically generated and updated using the `build-port-vulns-db.py` script which:

1. Retrieves port service descriptions from Nmap's service database
2. Queries the MITRE CVE database for vulnerabilities associated with each port
3. Filters vulnerabilities to include only those from the past 5 years
4. Verifies that vulnerability descriptions explicitly mention the port
5. Adds metadata including service names, descriptions, and protocol information
6. Generates a cryptographic signature for database integrity verification

The port vulnerability database enables EDAMAME to identify potentially vulnerable services running on endpoints within a network scan.

### Vendor Vulnerability Database

Similarly, the `lanscan-vendor-vulns-db.json` database tracks vulnerabilities associated with hardware vendors. It is generated by `build-vendor-vulns-db.py` which:

1. Retrieves vendor information from Wireshark's OUI database
2. Processes and normalizes vendor names for consistent matching
3. Queries the MITRE CVE database for vulnerabilities associated with each vendor
4. Retains only recent CVEs (past 4 years)
5. Organizes vulnerabilities by vendor with appropriate metadata
6. Signs the database for integrity verification

This database helps EDAMAME evaluate potential risks associated with specific hardware vendors detected on the network.

### Device Profile Database

The `lanscan-profiles-db.json` file contains rules for identifying device types based on their network characteristics. Unlike the vulnerability databases, this is primarily maintained manually to ensure accurate device type identification. The database:

1. Defines device types (printers, routers, IoT devices, etc.)
2. Contains logical rules for identifying each device type based on:
   - Open ports
   - mDNS service advertisements
   - Vendor information
   - Hostnames
   - Service banners
3. Implements complex condition trees using AND/OR logical operators
4. Supports negation of conditions for more precise matching

This database powers EDAMAME's device identification capabilities, allowing it to recognize and categorize devices on local networks.

### Whitelist Database

The `whitelists-db.json` database defines allowable network connections for different environments and scenarios. It contains:

1. Base whitelists for essential EDAMAME functionality
2. Specialized whitelists for development and CI/CD environments
3. Platform-specific whitelists (macOS, Linux, Windows)
4. Hierarchical definitions with inheritance support

Each whitelist entry can specify:
- Domains (including wildcard patterns)
- IP addresses (both specific and network ranges)
- Ports and protocols
- Autonomous System information (AS number, country, owner)
- Process-specific restrictions

#### Domain Wildcard Matching

The whitelist system supports wildcards that can match one or more complete domain components:

1. **Prefix Wildcards** (`*.example.com`): 
   - Matches any subdomain of example.com, regardless of depth
   - Examples: `sub.example.com`, `deep.sub.example.com`, `a.b.c.example.com`
   - Does not match the base domain itself (`example.com`)

2. **Middle Position Wildcards** (`example.*.com`):
   - Matches any domain with `example` as the first element and `com` as the last element
   - The wildcard can match one or more domain components
   - Examples: `example.test.com`, `example.one.two.three.com`

3. **Suffix Wildcards** (`example.*`):
   - Matches `example` domain with any suffix, regardless of depth
   - Examples: `example.com`, `example.org`, `example.co.uk`

Note: Each domain pattern can contain at most one wildcard character, but that wildcard can match multiple domain components. Partial wildcards within components (e.g., `ex*ample.com`) are not supported.

#### IP Address Matching

IP address matching supports both specific addresses and network ranges using standard notation.

This database enables EDAMAME to distinguish between legitimate and potentially unauthorized network connections, which is essential for security posture assessment.

### Database Integrity and Updates

All EDAMAME databases include:
- A timestamp indicating when they were last updated
- A cryptographic signature for integrity verification
- A structured format that supports easy parsing and validation

These databases are designed to be updated seamlessly from trusted sources while maintaining user privacy and security.

## Threat Dimensions

Security threats are categorized along 5 key dimensions:

| Dimension | Description |
|-----------|-------------|
| **Applications** | Application authorizations, EPP/antivirus, ... |
| **Network** | Network configuration, exposed services, ... |
| **Credentials** | Password policies, biometrics, 2FA, ... |
| **System Integrity** | MDM profiles, jailbreaking, 3rd party administrative access, ... |
| **System Services** | System configuration, service vulnerabilities, ... |

## Naming Conventions

Threat names follow these conventions:
- Describe the threat directly (not its remediation)
- No hyphens (`-`)
- Spaces are preferred over underscores (`_`)
- No special characters
- Lowercase except for acronyms and commercial names
- Example: `Chrome not uptodate`

## Model Structure

Each threat model is structured as a JSON file that defines:
1. **Threat metadata**: Information about the threat, including its name, description, severity, and impact
2. **Detection logic**: The checks and conditions used to detect the presence of the threat
3. **Remediation guidance**: Recommended actions to mitigate the threat
4. **References**: Links to standards, benchmarks, and other sources of information

### JSON Format

Each threat model file follows a standardized format:

```json
{
  "name": "threat model [Platform]",
  "extends": "none",
  "date": "Last update date",
  "signature": "Cryptographic signature of the model",
  "metrics": [
    {
      "name": "Threat name",
      "metrictype": "bool",
      "dimension": "One of the 5 dimensions",
      "severity": 1-5,
      "scope": "Platform-specific or generic",
      "tags": ["Compliance standards", "Benchmarks"],
      "description": [
        { "locale": "EN", "title": "Title", "summary": "Description" },
        { "locale": "FR", "title": "Titre", "summary": "Description" }
      ],
      "implementation": { ... },
      "remediation": { ... },
      "rollback": { ... }
    }
  ]
}
```

### Key Fields

**Top Level Properties:**
- **name**: The unique identifier of the threat model
- **extends**: Inheritance model, if applicable 
- **date**: Last update timestamp
- **signature**: Cryptographic signature for integrity verification
- **metrics**: Array of threat definitions

**Metric Properties:**
- **name**: The threat identifier
- **metrictype**: Type of measurement (typically boolean)
- **dimension**: The security dimension the threat belongs to
- **severity**: Impact rating from 1 (low) to 5 (critical)
- **scope**: Whether the threat is platform-specific or generic
- **tags**: Compliance references (e.g., CIS Benchmark, ISO 27001, SOC 2)
- **description**: Localized explanations of the threat
- **implementation**: Detection logic
- **remediation**: Steps to resolve the threat
- **rollback**: Steps to revert remediation if needed

## Implementation Types

Threat models employ different detection methods depending on the nature of the security check:

### System Checks
Direct checks of system configuration, file presence, or settings that can be evaluated through standard APIs.

### Command Line Checks
Safe, predefined commands that gather information about the system state. These commands are carefully vetted to ensure they cannot cause harm to the system.

### Business Rules
Specialized checks that execute local scripts in userspace, leveraging the `EDAMAME_BUSINESS_RULES_CMD`